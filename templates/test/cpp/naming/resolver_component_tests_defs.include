<%def name="resolver_component_tests(tests)">
DNS_PORT=`$PICK_PORT_BINPATH | grep "Got port" | awk '{print $3}'`
echo "dns port is $DNS_PORT"
if [[ $DNS_PORT == 0 ]]; then echo "failed to get port" && exit 1; fi

if [[ "$GRPC_DNS_RESOLVER" != "" && "$GRPC_DNS_RESOLVER" != ares ]]; then
  echo "This test only works under GRPC_DNS_RESOLVER=ares. Have GRPC_DNS_RESOLVER=$GRPC_DNS_RESOLVER" && exit 1
fi
export GRPC_DNS_RESOLVER=ares

echo "Start a local DNS server in the background on port $DNS_PORT"
$INVOKE_DNS_SERVER_CMD_WITHOUT_ARGS --dns_port="$DNS_PORT" 2>&1 > /dev/null &
DNS_SERVER_PID=$!
echo "Local DNS server started. PID: $DNS_SERVER_PID"

# Health check local DNS server TCP and UDP ports
for ((i=0;i<30;i++));
do
  echo "Retry health-check DNS query to local DNS server over tcp and udp"
  RETRY=0
  dig A health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp. @localhost -p $DNS_PORT +tries=1 +timeout=1 | grep '123.123.123.123' || RETRY=1
  dig A health-check-local-dns-server-is-alive.resolver-tests.grpctestingexp. @localhost -p $DNS_PORT +tries=1 +timeout=1 +tcp | grep '123.123.123.123' || RETRY=1
  if [[ $RETRY == 0 ]]; then
    break
  fi;
  sleep 0.1
done

if [[ $RETRY == 1 ]]; then
  echo "FAILED TO START LOCAL DNS SERVER"
  kill -SIGTERM $DNS_SERVER_PID
  wait
  exit 1
fi

function terminate_all {
  kill -SIGTERM $!
  kill -SIGTERM $DNS_SERVER_PID
  wait
  exit 1
}

trap terminate_all SIGTERM
EXIT_CODE=0

% for test in tests:
$RESOLVER_TEST_BINPATH \\

  --target_name='${test['target_name']}' \\

  --expected_addrs='${test['expected_addrs']}' \\

  --expected_chosen_service_config='${test['expected_chosen_service_config']}' \\

  --expected_lb_policy='${test['expected_lb_policy']}' \\

  --local_dns_server_address=127.0.0.1:$DNS_PORT &
wait $! || EXIT_CODE=1

% endfor
kill -SIGTERM $DNS_SERVER_PID
wait</%def>
